/**
 * @ngdoc object
 * @name orpc
 * @description
 * 	ORPC calls<br>
 *  See {@link http://visionmedia.github.io/superagent/} SuperAgent HTTP Request
 */

var request = require('superagent');
var envConf = require('../conf/env_conf.js'), env = new envConf();
var Serialize = require('./serialize.js'), serialize = new Serialize();

/**
 * @ngdoc Methods
 * @author Alex Arapu
 * @name sample
 * @methodOf orpc
 * @description return random value from array
 * @return {string|object|int} random value from array
 */
Array.prototype.sample = function() {
  return this[~~(Math.random() * this.length)];
};

var orpc = function () {
  var that = this;

  /**
   * @ngdoc Methods
   * @name runOrpcApi
   * @methodOf orpc
   * @description this method executes the orpc-api and returns the orpc-api output promise <br>
   * @param {string} api name
   * @param {object} params for orpc-api call, it should be an array
   * @author Alex Arapu
   * Examples: <br>
   <pre>
   //it will display the random active group_name
   page.orpc.runOrpcApi('Group::ListGroups', ['Active']).then(function (value) {
        console.log('Group:',value.sample()['group_name']);
      });
   </pre>
   <pre>
   //it will allocate the visitor to QT and will display the orpc output
   page.orpc.runOrpcApi('QTests::AllocateToMultipleTests', ['', '172.27.8.141.1458947006870632', ['ProfileSearchAgencyTile--Control']]).then(function (value) {
        console.log('QTests:', value);
      });
   </pre>
   */
  this.runOrpcApi = function (api, params) {
    return that.sendHttpRequest('post', env.data.orpc.app + api, [null, api, null].concat(params)).then(function(resp){
      return JSON.parse(resp.text)[1];
    });
  };

  /**
   * @ngdoc Methods
   * @name sendHttpRequest
   * @methodOf orpc
   * @description Provide http POST, get put request
   * @param {string} type  type of http request (POST/GET/PUT)
   * @param {string} requestUrl   the url from env.data
   * @param {string} requestBody   the request body format in JSON object
   * @returns {string} promise
   * @author Jason So
   */
  this.sendHttpRequest = function (type, requestUrl, requestBody) {
    var defer = protractor.promise.defer();
    var serializedRequestBody = serialize.serialize(requestBody);
    if(type.toString().toLowerCase() === 'post'){
      console.log("http-post");
      console.log(requestUrl);
      console.log(requestBody);
      console.log(serializedRequestBody);
      request
          .post(requestUrl)
          .send(serializedRequestBody)
          .set('Accept', 'application/json')
          .end(function (error, response) {
            if (error) {
//              console.error(error);
              defer.cancel(error);
            } else {
              defer.fulfill(response);
            }
          });
    } else if(type.toString().toLowerCase() === 'get'){
      console.log("http-get");
      request
          .get(requestUrl)
          .send(serializedRequestBody)
          .set('Accept', 'application/json')
          .end(function (error, response) {
            if (error) {
              console.error(error);
              defer.cancel(error);
            } else {
              defer.fulfill(response);
            }
          });
    } else if(type.toString().toLowerCase() === 'put'){
      console.log("http-put");
      request
          .put(requestUrl)
          .send(serializedRequestBody)
          .set('Accept', 'application/json')
          .end(function (error, response) {
            if (error) {
              console.error(error);
              defer.cancel(error);
            } else {
              defer.fulfill(response);
            }
          });
    }
    return defer.promise;
  };

  /**
   * @ngdoc Methods
   * @name postEmailToken
   * @methodOf orpc
   * @description NotifyUser::VerifyEmail. This will give you the email message id to be passed into postEmailToken.
   * @param {string} username Username of the account
   */
  this.postEmailToken = function (username) {
    var requestBody = 'a:4:{i:0;N;i:1;s:23:"NotifyUser::VerifyEmail";i:2;N;i:3;s:' + username.length + ':"' + username + '";}';
    var deferredRequest = protractor.promise.defer();
    request
      .post( env.data.orpcNotifyUserVerifyEmail)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name postEmailMessage
   * @methodOf orpc
   * @description Mail::GetMessage. This will pull up the email message that contain the authentication key.
   * @param {string} messageId This will return the email key to be verified.
   */
  this.postEmailMessage = function (messageId) {
    var requestBody = 'a:4:{i:0;N;i:1;s:16:"Mail::GetMessage";i:2;N;i:3;s:8:"' + messageId + '";}';
    var deferredRequest = protractor.promise.defer();
    request
      .post( env.data.orpcMailGetMessage)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name postEmailKey
   * @methodOf orpc
   * @description Registration::VerifyEmail. This will verify the email of the user account.
   * @param {string} username Username of the account
   * @param {string} emailKey This will be use to verify the email account from the email message received.
   */
  this.postEmailKey = function (username,emailKey) {
    var requestBody = 'a:4:{i:0;N;i:1;s:25:"Registration::VerifyEmail";i:2;a:1:{s:9:"RPC_LOGIN";s:' + username.length + ':"' + username + '";}i:3;s:18:"' + emailKey + '";}';
    var deferredRequest = protractor.promise.defer();
    request
      .post( env.data.orpcRegistrationVerifyEmail)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name verifyEmailAddress
   * @methodOf orpc
   * @param {string} username Username of the account
   * @description This will go through all the flow and verify the email of the user account. <br>
   * it('Verify Email', function(done){  <br>
   *   orpc.verifyEmailAddress(userInfo.username).then(done); <br>
   * });
   */
  this.verifyEmailAddress = function(username) {
    return that.postEmailToken(username).then(function (success){
      console.log(success.body[1][0]);
      return that.postEmailMessage(success.body[1][0]).then(function (success2){
        var emailKey = success2.body[1]['Text'].match(/token\/(.*)(\?|\s)/);
        console.log(emailKey[1]);
        return that.postEmailKey(username,emailKey[1]).then(function (success3){
          console.log(success3.body);
        });
      });
    });
  };

  /**
   * @ngdoc Methods
   * @name updateQTtest
   * @methodOf orpc
   * @param {string} username Username of the account
   * @param {string} qtTest name of the QT like EOM946_20Experience-Treatment
   * @description This will update one QT setting for a particular users <br>
   */
  this.updateQTtest = function (username, qtTest) {
    var requestBody = 'a:6:{i:0;N;i:1;s:31:"QTests::AllocateToMultipleTests";i:2;a:0:{}i:3;s:' + username.length +  ':"' + username + '";' +
      'i:4;N;i:5;a:1:{i:0;s:' + qtTest.toString().length + ':"' + qtTest + '";}}';
    var deferredRequest = protractor.promise.defer();
    request
      .post(env.data.orpcQTestsAllocateToMultipleTests)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    console.log('QT updated: ' + qtTest + " :: " + requestBody);
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name updateQTtests
   * @methodOf orpc
   * @param {string} username Username of the account
   * @param {array} qtTestArray Array that contain the name of QT like ["EOM946_20Experience-Treatment","Lam007_00Experience-Treatment"]
   * @description This will update one QT setting for a particular users <br>
   */
  this.updateQTtests = function (username, qtTestArray) {
    for (var i = 0 ; i< qtTestArray.length; i ++) {
      that.updateQTtest(username,qtTestArray[i]);
    }
  };

  /**
   * @ngdoc Methods
   * @name resetPassword
   * @methodOf orpc
   * @param {string} username Username of the account
   * @description This will update password of user to strange! . This uses jenkins job.<br>
   */
  this.resetPassword = function (username) {
    var requestBody = '';
    var deferredRequest = protractor.promise.defer();
    request
      .post('http://jenkinsqa.odesk.com:8080/job/Helper-ORPC/buildWithParameters?login=' + username + '&type=resetpassword')
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    console.log('password updated to strange! for: ' + username);
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name createFreelancerFullData
   * @methodOf orpc
   * @param {string} username Username of the account
   * @description This will trigger a jenkins job to run a jmeter script to generate a freelancer profile with fake profile data and be ready to use.<br>
   */
  this.createFreelancerFullData = function (username) {
    var requestBody = '';
    var deferredRequest = protractor.promise.defer();
    request
      .post('http://jenkinsqa.odesk.com:8080/job/Helper-CreateAccountFull/buildWithParameters?login=' + username + '&account=freelancerfull')
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    console.log('password updated to strange! for: ' + username);
    console.log('make sure to sleep for 100sec-120sec afterward for the job to finish running: http://jenkinsqa.odesk.com:8080/job/Helper-CreateAccountFull/');
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name createClientFullDataJet
   * @methodOf orpc
   * @param {string} clientUsername Username of the client account
   * @description This will trigger a jenkins job to run a JET script to generate a client profile with fake profile data and
   * a posted job ready to be use. Default password is strange! Sleep for 30-40 seconds for the job to complete<br>
   */
  this.createClientFullDataJet = function (clientUsername) {
    var requestBody = '';
    var deferredRequest = protractor.promise.defer();
    request
      .post('http://jenkinsqa.odesk.com:8080/job/misc.data.preparation.stage/buildWithParameters?CLIENT_USER_ID=' + clientUsername + '&USER_TYPE=client')
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    console.log('password updated to strange! for: ' + clientUsername);
    console.log('make sure to sleep for 30-40 sec afterward for the job to finish running: http://jenkinsqa.odesk.com:8080/job/misc.data.preparation.stage/');
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name createFreelancerFullDataJet
   * @methodOf orpc
   * @param {string} freelancerUsername Username of the freelancer account
   * @description This will trigger a jenkins job to run a JET script to generate a client profile with fake profile data .
   * Default password is strange! Sleep for 30-40 seconds for the job to complete<br>
   */
  this.createFreelancerFullDataJet = function (freelancerUsername) {
    var requestBody = '';
    var deferredRequest = protractor.promise.defer();
    request
      .post('http://jenkinsqa.odesk.com:8080/job/misc.data.preparation.stage/buildWithParameters?FREELANCER_USER_ID=' + freelancerUsername + '&USER_TYPE=freelancer')
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    console.log('password updated to strange! for: ' + freelancerUsername);
    console.log('make sure to sleep for 30-40 sec afterward for the job to finish running: http://jenkinsqa.odesk.com:8080/job/misc.data.preparation.stage/');
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name createClientFreelancerFullDataJet
   * @methodOf orpc
   * @param {string} freelancerUsername Username of the freelancer account
   * @param {string} clientUsername Username of the client account
   * @description This will trigger a jenkins job to run a JET script to generate a freealncer/client profile with fake profile data and
   * a posted job ready to be use. Default password is strange! Sleep for 50-70 seconds for the job to complete<br>
   */
  this.createClientFreelancerFullDataJet  = function (freelancerUsername, clientUsername) {
    var requestBody = '';
    var deferredRequest = protractor.promise.defer();
    request
      .post('http://jenkinsqa.odesk.com:8080/job/misc.data.preparation.stage/buildWithParameters?CLIENT_USER_ID=' + clientUsername + '&FREELANCER_USER_ID=' + freelancerUsername + '&USER_TYPE=both')
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    console.log('password updated to strange! for: ' + freelancerUsername + ' and ' + clientUsername);
    console.log('make sure to sleep for 50-70 sec afterward for the job to finish running: http://jenkinsqa.odesk.com:8080/job/misc.data.preparation.stage/');
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name createClientFreelancerJobPost
   * @methodOf orpc
   * @param {string} freelancerUsername of the freelancer account; must not exceed 16 chars
   * @param {string} clientUsername Username of the client account must not exceed 16 chars
   * @description This will trigger a jenkins job to run a jmeter script to generate a client, freelancer, and invite to 2 job posting. ~1.2 min <br>
   */
  this.createClientFreelancerJobPost = function (freelancerUsername, clientUsername) {
    var requestBody = '';
    var deferredRequest = protractor.promise.defer();
    request
      .post('http://jenkinsqa.odesk.com:8080/job/Helper-CreateAccountsJobPost/buildWithParameters?freelancerUsername=' + freelancerUsername + '&clientUsername=' + clientUsername)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });
    console.log('make sure to sleep for 1.2-1.5 sec afterward for the job to finish running: http://jenkinsqa.odesk.com:8080/job/Helper-CreateAccountsJobPost/');
    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name getUTCTimeNow
   * @methodOf orpc
   * @returns {string} timestamp
   * @description return an UTC timestamp in the format of yyyymmddThhmmssZ, e.g. 20150101T132605Z
   */
  this.getUTCTimeNow = function(){
    return new Date().toISOString()
      .replace(/-/g, '')
      .replace(/:/g, '')
      .replace(/....Z/, 'Z');
  };

  /**
   * @ngdoc Method
   * @name addManualTime
   * @methodOf orpc
   * @param {string} authId authorize id
   * @param {string} contractId contractor id
   * @param {String} timeInterval beginning and ending time interval
   * @param {string} memo memo description
   * @description This function will "Add Manual Time" for freelancer.
   *  e.g. addManualTime( "ic15041612534044", "13728882", "20150515T003528Z,20150515T003528Z" , "test memo")
   *
   *  The timeInterval string can be constructed by the return value of this function: orpc.getUTCTimeNow()
   *  So you can get the correct timeInterval string :
   *
   *      var timestamp = orpc.getUTCTimeNow();
   *      var timeInterval = timestamp + ","+ timestamp;
   *
   *  Then, you can provide the timeInterval to this function.
   */
  this.addManualTime = function(authId, contractId, timeInterval, memo){
    var requestBody = 'a:7:{i:0;N;i:1;s:29:"TeamRESTAdapter::AddMemoByCID";i:2;N;i:3;s:16:"'+authId+'";i:4;s:8:"'+contractId+'";i:5;s:33:"'+timeInterval+'";i:6;s:'+memo.length+':"'+memo+'";}';
    var deferredRequest = protractor.promise.defer();

    console.log(requestBody);

    request
      .post(env.data.orpcTeamRESTAdapterAddMemoByCID)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });

    return deferredRequest.promise;
  };

  /**
   * @ngdoc Method
   * @name clientSignupFromDesktop
   * @methodOf orpc
   * @param {string} username  username of client user
   * @description  This method will create a new client as the user sign up from desktop. The new client is not EV+PV compared to client sign up from mobile. Please see EOM-1772 for requirement description
   * Note: browser session is required to acquire the visitor_id cookie value.
   */
  this.clientSignupFromDesktop = function(username){
    var strlength = username.toString().length;
    var cookieLength;
    var requestBody;
    var deferredRequest = protractor.promise.defer();

    browser.manage().getCookie("visitor_id").then(function(cookie){
      cookieLength = cookie.value.toString().length;

      requestBody = 'a:11:{i:0;N;i:1;s:19:"Registration::Start";i:2;N;i:3;s:'+strlength+':"' + username +
        '";i:4;s:8:"strange!";i:5;s:9:"firstname";i:6;s:8:"lastname";i:7;s:32:"UTC (Coordinated Universal Time)";i:8;s:'+(strlength+7)+':"'+username+'@eo.com";'+
        'i:9;s:'+cookieLength+':"'+cookie.value+
        '";i:10;a:3:{s:11:"signup_flow";s:26:"registration_client_signup";s:13:"is_smartphone";s:1:"0";s:4:"type";s:2:"BS";}}';

      console.log(requestBody);

      request
        .post(env.data.orpcRegistrationStart)
        .send(requestBody)
        .set('Accept', 'application/json')
        .end(function (err, res) {
          if (err) {
            deferredRequest.cancel(err);
          } else {
            deferredRequest.fulfill(res);
          }
        });
    });
  };

  /**
   * @ngdoc Method
   * @name clientSignupFromMobile
   * @methodOf orpc
   * @param {string} username username of client user
   * @description  This method will create a new client as the user sign up from mobile devices. The new client is EV+PV compared to client sign up from desktop. Please see EOM-1772 for requirement description
   * Note: browser session is required to acquire the visitor_id cookie value.
   */
  this.clientSignupFromMobile = function(username){
    var strlength = username.toString().length;
    var cookieLength;
    var requestBody;
    var deferredRequest = protractor.promise.defer();

    browser.manage().getCookie("visitor_id").then(function(cookie){
      cookieLength = cookie.value.toString().length;

      requestBody = 'a:11:{i:0;N;i:1;s:19:"Registration::Start";i:2;N;i:3;s:'+strlength+':"' + username +
        '";i:4;s:8:"strange!";i:5;s:9:"firstname";i:6;s:8:"lastname";i:7;s:32:"UTC (Coordinated Universal Time)";i:8;s:'+(strlength+7)+':"'+username+'@eo.com";'+
        'i:9;s:'+cookieLength+':"'+cookie.value+
        '";i:10;a:3:{s:11:"signup_flow";s:26:"registration_client_signup";s:13:"is_smartphone";s:1:"1";s:4:"type";s:2:"BS";}}';

      console.log(requestBody);

      request
        .post(env.data.orpcRegistrationStart)
        .send(requestBody)
        .set('Accept', 'application/json')
        .end(function (err, res) {
          if (err) {
            deferredRequest.cancel(err);
          } else {
            deferredRequest.fulfill(res);
          }
        });
    });
  };

  /**
   * @ngdoc Method
   * @name jobPostWithNumberFreelancerToHire
   * @methodOf orpc
   * @param {string} username username of client user
   * @param {string} companyId  company ID
   * @param {string} jobTitle  job title
   * @param {string} jobDesc   job description
   * @param {string} numberFreelancerToHire number of freelancers to hire
   * @description  This method posts an hourly job with the number of freelancers to hire. This option is currently available only for desktop job post.
   */
  this.jobPostWithNumberFreelancerToHire = function( username, companyId, jobTitle, jobDesc, numberFreelancerToHire){
    var requestBody;
    var deferredRequest = protractor.promise.defer();
    console.log("Post hourly job with number of freelancers to hire: " + numberFreelancerToHire);

    requestBody = 'a:7:{i:0;N;i:1;s:27:"Engage::CreateOpeningFacade";i:2;a:1:{s:9:"RPC_LOGIN";s:'+ username.toString().length +':"'+ username +'";}' +
      'i:3;s:' + companyId.toString().length + ':"'+ companyId +'";' +
      'i:4;a:11:{s:24:"is_cover_letter_required";i:1;s:18:"oDeskTeamCompanyID";s:22:"_uus4cs8gczj7jkqxlif-g";s:27:"Rollup Company (ref) (snap)";i:'+ companyId +';s:6:"Status";s:9:"Requested";s:13:"Company (ref)";i:'+ companyId +';s:7:"JobType";s:6:"Hourly";' +
      's:23:"nbr_freelancers_to_hire";i:'+ numberFreelancerToHire +';s:13:"Opening Title";s:'+ jobTitle.toString().length +':"'+ jobTitle +'";s:15:"Job Description";s:'+ jobDesc.toString().length +':"'+ jobDesc +'";' +
      's:24:"JobProfileAccessOverride";s:6:"public";s:19:"Related JobCategory";i:19;}i:5;s:'+ username.toString().length +':"'+ username +'";i:6;s:6:"Hourly";}';

    console.log(requestBody);

    request
      .post(env.data.orpcRegistrationStart)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });

  };

  /**
   * @ngdoc Method
   * @name getProfileIdByUserId
   * @methodOf orpc
   * @param {string} userId username or userId for the freelancer
   * @description  This method posts a request to get the profile key/id for the provided username or userId
   */
  this.getProfileIdByUserId = function(userId){
    var requestBody;
    var deferredRequest = protractor.promise.defer();

    requestBody = 'a:4:{i:0;N;i:1;s:23:"Profile::GetKeyByUserId";i:2;N;i:3;s:'+userId.toString().length+':"'+userId+'";}';

    console.log(requestBody);

    request
      .post(env.data.orpcRegistrationStart)
      .send(requestBody)
      .set('Accept', 'application/json')
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        } else {
          deferredRequest.fulfill(res);
        }
      });

    return deferredRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name changeProfileState
   * @methodOf orpc
   * @description change the profile state
   * @author daniel roman terrazas
   * @param {json} data
   *
   *  var data ={ <br>
   *   username: usertest09, <br>
   *   state : "Acepted", <br>
   *   reason : "" <br>
   *  } <br>
   */
  this.changeProfileState=function(data){
    var config,rawResult,jsnObject,object;

    if (data.reason == null && data.reason == undefined)
      data.param3 = "";
    var requestBody="funcname="+encodeURIComponent("Profile::ChangeProfileState")+
      "&q_search=1&orpc_uri="+encodeURIComponent(env.data.orpc.uri)+
      "&rpc_login=&rpc_screen=index.php&batch_mode=0&bypass_cache=0&trim=0&trim=on"+
      "&isnull=0&isnull=on&escapehtml=0&escapehtml"+
      "&param1="+encodeURIComponent(data.userName)+"&param2="+encodeURIComponent(data.state)+
      "&param3="+encodeURIComponent(data.reason)+"&cp=3";
    var deferredRequest = protractor.promise.defer();
    request
      .post(env.data.orpc.url)
      .set('Content-Type','application/x-www-form-urlencoded')
      .set('Accept','text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8')
      .set('Upgrade-Insecure-Requests','1')
      .set('Origin',env.data.orpc.origin)
      .set('Authorization',env.data.orpc.authorization)
      .set('Connection','keep-alive')
      .set('Referer',env.data.orpc.url)
      .auth(env.data.user.admin.login,env.data.user.admin.password)
      .send(requestBody)
      .end(function (err, res) {
        if (err) {
          deferredRequest.cancel(err);
        }else{
          object = {
            statusCode :res.statusCode,
            response   : res ,
            responseObject : ""
          };
          deferredRequest.fulfill(object);
        }
      });
    return deferredRequest.promise;
  };

  /**
  * @ngdoc Methods
  * @name accountingGetAssociationByUserId
  * @methodOf orpc
  * @description call Accounting::GetAssociationByUserId on orpc endpoint
  * @author daniel roman terrazas
  * @param {string} legacyId  the user legacyid
  *
  * example
  *  it('accounting_getAssociationByUserId',function(){
  *     Orpc.accountingGetAssociationByUserId("freewgdamkxqja").then(function(object){
  *        console.log(object);
  *        console.log(object.dev_recno);
  *        console.log(object["dev_recno"]);
  *     });
  *  });
  **/
  this.accountingGetAssociationByUserId =function(legacyId){
    var requestUrl,serializedRequestBody,requestBody,promiseRequest;
    requestUrl = env.data.orpc.app+"Accounting::GetAssociationByUserId";
    requestBody = [null,"Accounting::GetAssociationByUserId",null,legacyId];
    serializedRequestBody = serialize.serialize(requestBody);
    console.log(requestUrl);
    console.log(requestBody);
    console.log(serializedRequestBody);
    promiseRequest =protractor.promise.defer();
    browser.wait(function(){
      var rawResult,jsnObject;
      var deferredRequest = protractor.promise.defer();
      request
        .post(requestUrl)
        .send(serializedRequestBody)
        .set('Accept', 'application/json')
        .auth(env.data.user.admin.login,env.data.user.admin.password)
        .end(function (error, response) {
          if (error) {
            deferredRequest.cancel(error);
          }else{
            rawResult =  response["text"];
            jsnObject =  eval("("+rawResult+")");
            deferredRequest.fulfill(jsnObject);
          }
        });
      return deferredRequest.promise;
    },60000,"time out accounting::GetAssociationByUserId").then(function(object){
       promiseRequest.fulfill(object[1]);
    });
    return promiseRequest.promise;
  };

  /**
  * @ngdoc Methods
  * @name qbUpdateCompany
  * @methodOf orpc
  * @description call QB::UpdateCompany on orpc end point
  * @param {int} companyRecno the company recno
  * @param {object} companyRecord  the company dataObject
  * @author daniel roman terrazas
  * example
  * it('accounting_getAssociationByUserId',function(){
  *   Orpc.accountingGetAssociationByUserId("cliojuthojtoc").then(function(object){
  *   var companyRecno =object.cnys[0];
  *   console.log(companyRecno);
  *   var companyRecord ={'TeamsEnabled' : true};
  *     Orpc.qbUpdateCompany(companyRecno,companyRecord).then(function(object){
  *       console.log(object);
  *     });
  *   });
  *});
  * **/
  this.qbUpdateCompany=function(companyRecno,companyRecord){
    companyRecord = companyRecord || {};
    var requestUrl,serializedRequestBody,requestBody,promiseRequest;
    requestUrl = env.data.orpc.app+"QB::UpdateCompany";
    requestBody = [null,"QB::UpdateCompany",null,companyRecno,companyRecord];
    serializedRequestBody = serialize.serialize(requestBody);
    console.log(requestUrl);
    console.log(requestBody);
    console.log(serializedRequestBody);
    promiseRequest =protractor.promise.defer();
    browser.wait(function(){
      var rawResult,jsnObject;
      var deferredRequest = protractor.promise.defer();
      request
        .post(requestUrl)
        .send(serializedRequestBody)
        .set('Accept', 'application/json')
        .auth(env.data.user.admin.login,env.data.user.admin.password)
        .end(function (error, response) {
          if (error) {
            deferredRequest.cancel(error);
          }else{
            rawResult =  response["text"];
            jsnObject =  eval("("+rawResult+")");
            deferredRequest.fulfill(jsnObject);
          }
        });
      return deferredRequest.promise;
    },60000,"time out qbUpdateCompany").then(function(object){
      promiseRequest.fulfill(object[1]);
    });
    return promiseRequest.promise;
  };

  /**
  * @ngdoc Methods
  * @name enableTeams
  * @methodOf orpc
  * @description enable company teams
  * @param {String} legacyId user legacyid
  * @author daniel roman terrazas
  * it('enableTeams',function(){
  *   Orpc.enableTeams("cliojuthojtoc").then(function(object){
  *  console.log(object);
  *   });
  * });
  **/
  this.enableTeams = function(legacyId){
    var deferredRequest = protractor.promise.defer();
    var associationByUserId,companyRecno,companyRecord;
    companyRecord ={'TeamsEnabled' : true};
    browser.wait(that.accountingGetAssociationByUserId(legacyId),60000,"time out accounting_getAssociationByUserId").
      then(function(object){
        associationByUserId = object;
        if(associationByUserId.cnys.length == 0)
          return ;
        companyRecno = associationByUserId.cnys["0"];
        browser.wait(that.qbUpdateCompany(companyRecno,companyRecord),60000,"time out qb_updateCompany").
          then(function(object1){
              deferredRequest.fulfill(object1);
        });
    });
    return deferredRequest.promise;
  };

  /**
  * @ngdoc Methods
  * @name profileChangeProfileState
  * @methodOf orpc
  * @description call Profile::ChangeProfileState on orpc end point
  * @param {string} legacyId the user legacy id
  * @param {String} state  the new profile state. Accepted by default
  * @author daniel roman terrazas
  * example
  * it("changeState",function(){
  *   Orpc.profileChangeProfileState("mmraz318").then(function(object){
  *     console.log(object);
  *   });
  * });
  * **/
  this.profileChangeProfileState = function(legacyId,state){
    state  = state  || "Accepted";
    var requestUrl,serializedRequestBody,requestBody,promiseRequest;
    requestUrl = env.data.orpc.app+"Profile::ChangeProfileState";
    requestBody = [null,"Profile::ChangeProfileState",null,legacyId,state];
    serializedRequestBody = serialize.serialize(requestBody);
    console.log(requestUrl);
    console.log(requestBody);
    console.log(serializedRequestBody);
    promiseRequest =protractor.promise.defer();
    browser.wait(function(){
      var rawResult,jsnObject;
      var deferredRequest = protractor.promise.defer();
      request
        .post(requestUrl)
        .send(serializedRequestBody)
        .set('Accept', 'application/json')
        .auth(env.data.user.admin.login,env.data.user.admin.password)
        .end(function (error, response) {
          if (error) {
            deferredRequest.cancel(error);
          }else{
            rawResult =  response["text"];
            jsnObject =  eval("("+rawResult+")");
            deferredRequest.fulfill(jsnObject);
          }
        });
      return deferredRequest.promise;
    },60000,"time out profileChangeProfileState").then(function(object){
      promiseRequest.fulfill(object[1]);
    });
    return promiseRequest.promise;
  };

  /**
   * @ngdoc Methods
   * @name getUserType
   * @methodOf orpc
   * @description return User Type
   * @author Alex Arapu
   */
  this.getUserType = function () {
    return browser.driver.executeScript("return Applet.getUser().getNid()").then(function (user) {
      if (env.data.envConfig != 'prod') {
        return that.runOrpcApi('Ops::GetUserType', [user]).then(function (value) {
          return value[user]
        });
      } else{
        return env.data.user.em == user ? 'buyer' : 'provider';
      }
    });
  };

  /**
   * @ngdoc Methods
   * @name getOrpcCategories
   * @methodOf orpc
   * @description return an array of random Category and Subcategory or All Categories from ORPC
   * @param {string} param random or all
   * @author Alex Arapu
   */
  this.getOrpcCategories = function (param) {
    if (param == null || param =='all') {
      return that.runOrpcApi('QB::GetJobCategories');
    } else if (param == 'random'){
      return that.runOrpcApi('QB::GetJobCategories').then(function(value){
        var category = value.sample();
        var subcategory = category.topics.sample();
        return [category.title, subcategory.title];
      });
    }
  };

  /**
   * @ngdoc Methods
   * @author Alex Arapu
   * @name getRandomGroup
   * @methodOf orpc
   * @description get Random Group
   * @return {string|object} random group
   */
  this.getRandomGroup = function (){
    if (env.data.envConfig != 'prod') {
      return that.runOrpcApi('Group::ListGroups', ['Active', '0', '3000', 'group_name', 'desc']).then(function (groups) {
        var group_ids = [];
        for(var i=0; i<groups.length; i++){
          if(parseInt(groups[i]['num_group_members'])>2){
            group_ids.push(groups[i]['group_id']);
          }
        }
        return group_ids.sample();
      });
    } else {
      return ['ebay','bigcommerce','phpfox','corona'].sample();
    }
  };

  /**
   * @ngdoc Methods
   * @author Alex Arapu
   * @name is_QtSet
   * @methodOf orpc
   * @description check Qt Allocation on Angular page
   * @return {boolean} boole true or false
   * @param {string} qt value
   * @param {string} cell value
   */
  this.is_QtSet = function (qt, cell) {
    if (env.data.envConfig != 'prod') {
      return browser.driver.executeScript("return Applet.getUser()").then(function (user) {
        if (user) {
          return browser.driver.executeScript("return Applet.getUser().getNid()").then(function (user) {
            return that.runOrpcApi('QTests::GetUserAllocations', [user]).then(function (value) {
              return value[qt] == cell;
            });
          });
        } else {
          return browser.driver.executeScript("return Applet.getVisitorId()").then(function (visitorId) {
            return that.runOrpcApi('QTests::GetTestCellByVisitorId', [visitorId]).then(function (value) {
              return value[qt] == cell;
            });
          });
        }
      });
    } else {
      return false;
    }
  };

  /**
   * @ngdoc Methods
   * @author Alex Arapu
   * @name set_qt
   * @methodOf orpc
   * @description set Qt Allocation on Angular page
   * @return {object} return the status promise
   * @param {string} qt value
   * @param {string} cell value
   */
  this.set_qt = function (qt, cell) {
    var api = 'QTests::AllocateToMultipleTests';

    if (env.data.envConfig != 'prod') {
      return browser.driver.executeScript("return Applet.getUser()").then(function (user) {
        if (user) {
          return browser.driver.executeScript("return Applet.getUser().getNid()").then(function (userId) {
            return that.runOrpcApi(api, [userId, '', [qt+'--'+cell]]).then(function (value) {
              return value;
            });
          });
        } else {
          return browser.driver.executeScript("return Applet.getVisitorId()").then(function (visitorId) {
            return that.runOrpcApi(api, ['', visitorId, [qt+'--'+cell]]).then(function (value) {
              return value;
            });
          });
        }
      });
    } else {
      return 'Prod environment, can not allocate the QT!' + qt + cell;
    }
  };

};
module.exports = orpc;

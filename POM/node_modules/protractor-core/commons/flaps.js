/**
 * This is a module to get access from the JavaScript code to the Flaps service
 *
 * @author  Alexander Kirilov
 * @version 1.0
 * @since   2016-02-08
 */
'use strict';
var Flaps = function() {

   const net = require('net');

   let host;
   let port;
   let timeout;

   let ready = false;

   // Flaps error handling function
   this.errorHandler = (error) => {
      console.log(error);
      process.exit(1);
   }

   this.ready = function(phost, pport, ptimeout) {
      host = phost;
      port = pport;
      timeout = ptimeout * 60 * 1000;

      let conn = new net.Socket();

      try {
         return new Promise((resolve, reject) => {
            conn.connect(port, host, () => {
               conn.write('READY?\n');

               conn.on('error', (error) => {
                  reject(new Error("Flaps service isn't ready"));
               });

               conn.on('data', (data) => {
                  conn.destroy();

                  if (String(data).trim() == 'OK') {
                     ready = true;

                     resolve();
                  } else {
                     reject(new Error("Unknown service responce"));
                  }
               })
            })
         })
      } catch (ex) {
         reject(ex)
      }
   };

   this.env = function() {
      let conn = new net.Socket();

      return new Promise((resolve, reject) => {
         if (ready) {
            try {
               conn.connect(port, host, () => {
                  conn.write('ENV?\n');

                  conn.on('error', (error) => {
                     reject(new Error("Flaps service is't ready"));
                  });

                  conn.on('data', (data) => {
                     conn.destroy();

                     let res = String(data).trim();

                     if (res.startsWith('ENV,')) {
                        resolve(res.substr(4).split(','));
                     } else {
                        reject(new Error("Unknown service responce"));
                     }
                  });
               })
            } catch (ex) {
               reject(new Error("Unknown service responce"));
            }
         } else {
            reject(new Error("Flaps service is't ready"));
         }
      })
   }

   this.supports = function() {
      let conn = new net.Socket();

      return new Promise((resolve, reject) => {
         if (ready) {
            try {
               conn.connect(port, host, () => {
                  conn.write('SUPPORT?\n');

                  conn.on('error', (error) => {
                     reject(new Error("Flaps service is't ready"));
                  });

                  conn.on('data', (data) => {
                     conn.destroy();

                     let res = String(data).trim();

                     if (res.startsWith('SUP,')) {
                        resolve(res.substr(4).split(','));
                     } else {
                        reject(new Error("Unknown service responce"));
                     }
                  });
               })
            } catch (ex) {
               reject(new Error("Unknown service responce"));
            }
         } else {
            reject(new Error("Flaps service is't ready"));
         }
      })
   }

   this.user = (data) => {
      let conn = new net.Socket();
      let trigger = true;
      let res = '';

      return new Promise((resolve, reject) => {
        if (ready) {
          try {
            conn.connect(port, host, () => {
              //-------------------------------------------------------------------
              conn.write('USER\n');
              conn.write(`${JSON.stringify(data)}\n`);
              //-------------------------------------------------------------------
              conn.on('error', (error) => {
                  reject(new Error("Flaps service is't ready"));
              });
              //-------------------------------------------------------------------
              conn.on('data', (chunk) => {
                  res = res + String(chunk).trim(); // append data in order to not miss TCP packets; kinda node.js issue
                  //console.log('got %d bytes of data', chunk.length);

                  if (trigger) {
                      if (res == 'ACCEPTED') {
                          trigger = false; // wait for user data
                          res     = '';    // reset data placeholder to store user info
                          // TODO: Set connection timeout on receiving user data ?
                      } else {
                          reject(new Error(`Unsupported user type "${data['type']}"`));
                      }
                  }
              });
              //-------------------------------------------------------------------
              conn.on('end', function() {
                  if (res) {
                      conn.destroy();

                      if (res.startsWith('00')) {
                          resolve(JSON.parse(res.substr(2)));
                      } else {
                          // TODO: Process server side errors with codes 01 etc.
                          reject(new Error('Server side error'));
                      }
                  }
              });
              //-------------------------------------------------------------------
            })
          } catch (ex) {
              reject(new Error("Unknown service responce"));
          }
        } else {
          reject(new Error("Flaps service is't ready"));
        }
      })
   }

   var self = this;

   this.signup = function(data) {

      var flow = protractor.promise.controlFlow();
      var defer = protractor.promise.defer();

      flow.execute(function() {
         self.ready("172.27.67.233", 4567, 3).then(function() {
            console.log('Flaps service is ready on 172.27.67.233:4567');
         }).then(function() {
            console.log('Request Flaps service to signup ' + data.type);
            return self.user(data);
         }).then(function(user) {
            if (user === undefined) {
               defer.reject();
            } else {
               defer.fulfill(user);
            }
         });
      });

      return defer.promise;
   };
};
module.exports = Flaps;